{
  "version": 3,
  "sources": ["nomod.js"],
  "sourcesContent": ["/* \n * QR Code generator library (JavaScript)\n * \n * Copyright (c) Project Nayuki. (MIT License)\n * https://www.nayuki.io/page/qr-code-generator-library\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided \"as is\", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\n\"use strict\";\nvar qrcodegen = new function () {\n\n\t/*---- QR Code symbol class ----*/\n\n\t/* \n\t * A class that represents a QR Code symbol, which is a type of two-dimension barcode.\n\t * Invented by Denso Wave and described in the ISO/IEC 18004 standard.\n\t * Instances of this class represent an immutable square grid of black and white cells.\n\t * The class provides static factory functions to create a QR Code from text or binary data.\n\t * The class covers the QR Code Model 2 specification, supporting all versions (sizes)\n\t * from 1 to 40, all 4 error correction levels, and 4 character encoding modes.\n\t * \n\t * Ways to create a QR Code object:\n\t * - High level: Take the payload data and call QrCode.encodeText() or QrCode.encodeBinary().\n\t * - Mid level: Custom-make the list of segments and call QrCode.encodeSegments().\n\t * - Low level: Custom-make the array of data codeword bytes (including\n\t *   segment headers and final padding, excluding error correction codewords),\n\t *   supply the appropriate version number, and call the QrCode() constructor.\n\t * (Note that all ways require supplying the desired error correction level.)\n\t * \n\t * This constructor creates a new QR Code with the given version number,\n\t * error correction level, data codeword bytes, and mask number.\n\t * This is a low-level API that most users should not use directly.\n\t * A mid-level API is the encodeSegments() function.\n\t */\n\tthis.QrCode = function (version, errCorLvl, dataCodewords, mask) {\n\n\t\t/*---- Constructor (low level) ----*/\n\n\t\t// Check scalar arguments\n\t\tif (version < MIN_VERSION || version > MAX_VERSION)\n\t\t\tthrow \"Version value out of range\";\n\t\tif (mask < -1 || mask > 7)\n\t\t\tthrow \"Mask value out of range\";\n\t\tif (!(errCorLvl instanceof Ecc))\n\t\t\tthrow \"QrCode.Ecc expected\";\n\t\tvar size = version * 4 + 17;\n\n\t\t// Initialize both grids to be size*size arrays of Boolean false\n\t\tvar row = [];\n\t\tfor (var i = 0; i < size; i++)\n\t\t\trow.push(false);\n\t\tvar modules = []; // Initially all white\n\t\tvar isFunction = [];\n\t\tfor (var i = 0; i < size; i++) {\n\t\t\tmodules.push(row.slice());\n\t\t\tisFunction.push(row.slice());\n\t\t}\n\n\t\t// Compute ECC, draw modules\n\t\tdrawFunctionPatterns();\n\t\tvar allCodewords = addEccAndInterleave(dataCodewords);\n\t\tdrawCodewords(allCodewords);\n\n\t\t// Do masking\n\t\tif (mask == -1) { // Automatically choose best mask\n\t\t\tvar minPenalty = Infinity;\n\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\tapplyMask(i);\n\t\t\t\tdrawFormatBits(i);\n\t\t\t\tvar penalty = getPenaltyScore();\n\t\t\t\tif (penalty < minPenalty) {\n\t\t\t\t\tmask = i;\n\t\t\t\t\tminPenalty = penalty;\n\t\t\t\t}\n\t\t\t\tapplyMask(i); // Undoes the mask due to XOR\n\t\t\t}\n\t\t}\n\t\tif (mask < 0 || mask > 7)\n\t\t\tthrow \"Assertion error\";\n\t\tapplyMask(mask); // Apply the final choice of mask\n\t\tdrawFormatBits(mask); // Overwrite old format bits\n\n\t\tisFunction = null;\n\n\n\t\t/*---- Read-only instance properties ----*/\n\n\t\t// The version number of this QR Code, which is between 1 and 40 (inclusive).\n\t\t// This determines the size of this barcode.\n\t\tObject.defineProperty(this, \"version\", {\n\t\t\tvalue: version\n\t\t});\n\n\t\t// The width and height of this QR Code, measured in modules, between\n\t\t// 21 and 177 (inclusive). This is equal to version * 4 + 17.\n\t\tObject.defineProperty(this, \"size\", {\n\t\t\tvalue: size\n\t\t});\n\n\t\t// The error correction level used in this QR Code.\n\t\tObject.defineProperty(this, \"errorCorrectionLevel\", {\n\t\t\tvalue: errCorLvl\n\t\t});\n\n\t\t// The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).\n\t\t// Even if a QR Code is created with automatic masking requested (mask = -1),\n\t\t// the resulting object still has a mask value between 0 and 7.\n\t\tObject.defineProperty(this, \"mask\", {\n\t\t\tvalue: mask\n\t\t});\n\n\n\t\t/*---- Accessor methods ----*/\n\n\t\t// Returns the color of the module (pixel) at the given coordinates, which is false\n\t\t// for white or true for black. The top left corner has the coordinates (x=0, y=0).\n\t\t// If the given coordinates are out of bounds, then false (white) is returned.\n\t\tthis.getModule = function (x, y) {\n\t\t\treturn 0 <= x && x < size && 0 <= y && y < size && modules[y][x];\n\t\t};\n\n\n\t\t/*---- Public instance methods ----*/\n\n\t\t// Draws this QR Code, with the given module scale and border modules, onto the given HTML\n\t\t// canvas element. The canvas's width and height is resized to (this.size + border * 2) * scale.\n\t\t// The drawn image is be purely black and white, and fully opaque.\n\t\t// The scale must be a positive integer and the border must be a non-negative integer.\n\t\tthis.drawCanvas = function (scale, border, canvas) {\n\t\t\tif (scale <= 0 || border < 0)\n\t\t\t\tthrow \"Value out of range\";\n\t\t\tvar width = (size + border * 2) * scale;\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = width;\n\t\t\tvar ctx = canvas.getContext(\"2d\");\n\t\t\tfor (var y = -border; y < size + border; y++) {\n\t\t\t\tfor (var x = -border; x < size + border; x++) {\n\t\t\t\t\tctx.fillStyle = this.getModule(x, y) ? \"#000000\" : \"#FFFFFF\";\n\t\t\t\t\tctx.fillRect((x + border) * scale, (y + border) * scale, scale, scale);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Returns a string of SVG code for an image depicting this QR Code, with the given number\n\t\t// of border modules. The string always uses Unix newlines (\\n), regardless of the platform.\n\t\tthis.toSvgString = function (border) {\n\t\t\tif (border < 0)\n\t\t\t\tthrow \"Border must be non-negative\";\n\t\t\tvar parts = [];\n\t\t\tfor (var y = 0; y < size; y++) {\n\t\t\t\tfor (var x = 0; x < size; x++) {\n\t\t\t\t\tif (this.getModule(x, y))\n\t\t\t\t\t\tparts.push(\"M\" + (x + border) + \",\" + (y + border) + \"h1v1h-1z\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' +\n\t\t\t\t'<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\\n' +\n\t\t\t\t'<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 ' +\n\t\t\t\t(size + border * 2) + ' ' + (size + border * 2) + '\" stroke=\"none\">\\n' +\n\t\t\t\t'\\t<rect width=\"100%\" height=\"100%\" fill=\"#FFFFFF\"/>\\n' +\n\t\t\t\t'\\t<path d=\"' + parts.join(\" \") + '\" fill=\"#000000\"/>\\n' +\n\t\t\t\t'</svg>\\n';\n\t\t};\n\n\n\t\t/*---- Private helper methods for constructor: Drawing function modules ----*/\n\n\t\t// Reads this object's version field, and draws and marks all function modules.\n\t\tfunction drawFunctionPatterns() {\n\t\t\t// Draw horizontal and vertical timing patterns\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tsetFunctionModule(6, i, i % 2 == 0);\n\t\t\t\tsetFunctionModule(i, 6, i % 2 == 0);\n\t\t\t}\n\n\t\t\t// Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)\n\t\t\tdrawFinderPattern(3, 3);\n\t\t\tdrawFinderPattern(size - 4, 3);\n\t\t\tdrawFinderPattern(3, size - 4);\n\n\t\t\t// Draw numerous alignment patterns\n\t\t\tvar alignPatPos = getAlignmentPatternPositions();\n\t\t\tvar numAlign = alignPatPos.length;\n\t\t\tfor (var i = 0; i < numAlign; i++) {\n\t\t\t\tfor (var j = 0; j < numAlign; j++) {\n\t\t\t\t\t// Don't draw on the three finder corners\n\t\t\t\t\tif (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0))\n\t\t\t\t\t\tdrawAlignmentPattern(alignPatPos[i], alignPatPos[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Draw configuration data\n\t\t\tdrawFormatBits(0); // Dummy mask value; overwritten later in the constructor\n\t\t\tdrawVersion();\n\t\t}\n\n\n\t\t// Draws two copies of the format bits (with its own error correction code)\n\t\t// based on the given mask and this object's error correction level field.\n\t\tfunction drawFormatBits(mask) {\n\t\t\t// Calculate error correction code and pack bits\n\t\t\tvar data = errCorLvl.formatBits << 3 | mask; // errCorrLvl is uint2, mask is uint3\n\t\t\tvar rem = data;\n\t\t\tfor (var i = 0; i < 10; i++)\n\t\t\t\trem = (rem << 1) ^ ((rem >>> 9) * 0x537);\n\t\t\tvar bits = (data << 10 | rem) ^ 0x5412; // uint15\n\t\t\tif (bits >>> 15 != 0)\n\t\t\t\tthrow \"Assertion error\";\n\n\t\t\t// Draw first copy\n\t\t\tfor (var i = 0; i <= 5; i++)\n\t\t\t\tsetFunctionModule(8, i, getBit(bits, i));\n\t\t\tsetFunctionModule(8, 7, getBit(bits, 6));\n\t\t\tsetFunctionModule(8, 8, getBit(bits, 7));\n\t\t\tsetFunctionModule(7, 8, getBit(bits, 8));\n\t\t\tfor (var i = 9; i < 15; i++)\n\t\t\t\tsetFunctionModule(14 - i, 8, getBit(bits, i));\n\n\t\t\t// Draw second copy\n\t\t\tfor (var i = 0; i < 8; i++)\n\t\t\t\tsetFunctionModule(size - 1 - i, 8, getBit(bits, i));\n\t\t\tfor (var i = 8; i < 15; i++)\n\t\t\t\tsetFunctionModule(8, size - 15 + i, getBit(bits, i));\n\t\t\tsetFunctionModule(8, size - 8, true); // Always black\n\t\t}\n\n\n\t\t// Draws two copies of the version bits (with its own error correction code),\n\t\t// based on this object's version field, iff 7 <= version <= 40.\n\t\tfunction drawVersion() {\n\t\t\tif (version < 7)\n\t\t\t\treturn;\n\n\t\t\t// Calculate error correction code and pack bits\n\t\t\tvar rem = version; // version is uint6, in the range [7, 40]\n\t\t\tfor (var i = 0; i < 12; i++)\n\t\t\t\trem = (rem << 1) ^ ((rem >>> 11) * 0x1F25);\n\t\t\tvar bits = version << 12 | rem; // uint18\n\t\t\tif (bits >>> 18 != 0)\n\t\t\t\tthrow \"Assertion error\";\n\n\t\t\t// Draw two copies\n\t\t\tfor (var i = 0; i < 18; i++) {\n\t\t\t\tvar bit = getBit(bits, i);\n\t\t\t\tvar a = size - 11 + i % 3;\n\t\t\t\tvar b = Math.floor(i / 3);\n\t\t\t\tsetFunctionModule(a, b, bit);\n\t\t\t\tsetFunctionModule(b, a, bit);\n\t\t\t}\n\t\t}\n\n\n\t\t// Draws a 9*9 finder pattern including the border separator,\n\t\t// with the center module at (x, y). Modules can be out of bounds.\n\t\tfunction drawFinderPattern(x, y) {\n\t\t\tfor (var dy = -4; dy <= 4; dy++) {\n\t\t\t\tfor (var dx = -4; dx <= 4; dx++) {\n\t\t\t\t\tvar dist = Math.max(Math.abs(dx), Math.abs(dy)); // Chebyshev/infinity norm\n\t\t\t\t\tvar xx = x + dx,\n\t\t\t\t\t\tyy = y + dy;\n\t\t\t\t\tif (0 <= xx && xx < size && 0 <= yy && yy < size)\n\t\t\t\t\t\tsetFunctionModule(xx, yy, dist != 2 && dist != 4);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t// Draws a 5*5 alignment pattern, with the center module\n\t\t// at (x, y). All modules must be in bounds.\n\t\tfunction drawAlignmentPattern(x, y) {\n\t\t\tfor (var dy = -2; dy <= 2; dy++) {\n\t\t\t\tfor (var dx = -2; dx <= 2; dx++)\n\t\t\t\t\tsetFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);\n\t\t\t}\n\t\t}\n\n\n\t\t// Sets the color of a module and marks it as a function module.\n\t\t// Only used by the constructor. Coordinates must be in bounds.\n\t\tfunction setFunctionModule(x, y, isBlack) {\n\t\t\tmodules[y][x] = isBlack;\n\t\t\tisFunction[y][x] = true;\n\t\t}\n\n\n\t\t/*---- Private helper methods for constructor: Codewords and masking ----*/\n\n\t\t// Returns a new byte string representing the given data with the appropriate error correction\n\t\t// codewords appended to it, based on this object's version and error correction level.\n\t\tfunction addEccAndInterleave(data) {\n\t\t\tif (data.length != QrCode.getNumDataCodewords(version, errCorLvl))\n\t\t\t\tthrow \"Invalid argument\";\n\n\t\t\t// Calculate parameter numbers\n\t\t\tvar numBlocks = QrCode.NUM_ERROR_CORRECTION_BLOCKS[errCorLvl.ordinal][version];\n\t\t\tvar blockEccLen = QrCode.ECC_CODEWORDS_PER_BLOCK[errCorLvl.ordinal][version];\n\t\t\tvar rawCodewords = Math.floor(QrCode.getNumRawDataModules(version) / 8);\n\t\t\tvar numShortBlocks = numBlocks - rawCodewords % numBlocks;\n\t\t\tvar shortBlockLen = Math.floor(rawCodewords / numBlocks);\n\n\t\t\t// Split data into blocks and append ECC to each block\n\t\t\tvar blocks = [];\n\t\t\tvar rsDiv = QrCode.reedSolomonComputeDivisor(blockEccLen);\n\t\t\tfor (var i = 0, k = 0; i < numBlocks; i++) {\n\t\t\t\tvar dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));\n\t\t\t\tk += dat.length;\n\t\t\t\tvar ecc = QrCode.reedSolomonComputeRemainder(dat, rsDiv);\n\t\t\t\tif (i < numShortBlocks)\n\t\t\t\t\tdat.push(0);\n\t\t\t\tblocks.push(dat.concat(ecc));\n\t\t\t}\n\n\t\t\t// Interleave (not concatenate) the bytes from every block into a single sequence\n\t\t\tvar result = [];\n\t\t\tfor (var i = 0; i < blocks[0].length; i++) {\n\t\t\t\tfor (var j = 0; j < blocks.length; j++) {\n\t\t\t\t\t// Skip the padding byte in short blocks\n\t\t\t\t\tif (i != shortBlockLen - blockEccLen || j >= numShortBlocks)\n\t\t\t\t\t\tresult.push(blocks[j][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result.length != rawCodewords)\n\t\t\t\tthrow \"Assertion error\";\n\t\t\treturn result;\n\t\t}\n\n\n\t\t// Draws the given sequence of 8-bit codewords (data and error correction) onto the entire\n\t\t// data area of this QR Code. Function modules need to be marked off before this is called.\n\t\tfunction drawCodewords(data) {\n\t\t\tif (data.length != Math.floor(QrCode.getNumRawDataModules(version) / 8))\n\t\t\t\tthrow \"Invalid argument\";\n\t\t\tvar i = 0; // Bit index into the data\n\t\t\t// Do the funny zigzag scan\n\t\t\tfor (var right = size - 1; right >= 1; right -= 2) { // Index of right column in each column pair\n\t\t\t\tif (right == 6)\n\t\t\t\t\tright = 5;\n\t\t\t\tfor (var vert = 0; vert < size; vert++) { // Vertical counter\n\t\t\t\t\tfor (var j = 0; j < 2; j++) {\n\t\t\t\t\t\tvar x = right - j; // Actual x coordinate\n\t\t\t\t\t\tvar upward = ((right + 1) & 2) == 0;\n\t\t\t\t\t\tvar y = upward ? size - 1 - vert : vert; // Actual y coordinate\n\t\t\t\t\t\tif (!isFunction[y][x] && i < data.length * 8) {\n\t\t\t\t\t\t\tmodules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// If this QR Code has any remainder bits (0 to 7), they were assigned as\n\t\t\t\t\t\t// 0/false/white by the constructor and are left unchanged by this method\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i != data.length * 8)\n\t\t\t\tthrow \"Assertion error\";\n\t\t}\n\n\n\t\t// XORs the codeword modules in this QR Code with the given mask pattern.\n\t\t// The function modules must be marked and the codeword bits must be drawn\n\t\t// before masking. Due to the arithmetic of XOR, calling applyMask() with\n\t\t// the same mask value a second time will undo the mask. A final well-formed\n\t\t// QR Code needs exactly one (not zero, two, etc.) mask applied.\n\t\tfunction applyMask(mask) {\n\t\t\tif (mask < 0 || mask > 7)\n\t\t\t\tthrow \"Mask value out of range\";\n\t\t\tfor (var y = 0; y < size; y++) {\n\t\t\t\tfor (var x = 0; x < size; x++) {\n\t\t\t\t\tvar invert;\n\t\t\t\t\tswitch (mask) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tinvert = (x + y) % 2 == 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tinvert = y % 2 == 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tinvert = x % 3 == 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tinvert = (x + y) % 3 == 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tinvert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\tinvert = x * y % 2 + x * y % 3 == 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 6:\n\t\t\t\t\t\t\tinvert = (x * y % 2 + x * y % 3) % 2 == 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 7:\n\t\t\t\t\t\t\tinvert = ((x + y) % 2 + x * y % 3) % 2 == 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow \"Assertion error\";\n\t\t\t\t\t}\n\t\t\t\t\tif (!isFunction[y][x] && invert)\n\t\t\t\t\t\tmodules[y][x] = !modules[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t// Calculates and returns the penalty score based on state of this QR Code's current modules.\n\t\t// This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.\n\t\tfunction getPenaltyScore() {\n\t\t\tvar result = 0;\n\n\t\t\t// Adjacent modules in row having same color, and finder-like patterns\n\t\t\tfor (var y = 0; y < size; y++) {\n\t\t\t\tvar runColor = false;\n\t\t\t\tvar runX = 0;\n\t\t\t\tvar runHistory = [0, 0, 0, 0, 0, 0, 0];\n\t\t\t\tvar padRun = size;\n\t\t\t\tfor (var x = 0; x < size; x++) {\n\t\t\t\t\tif (modules[y][x] == runColor) {\n\t\t\t\t\t\trunX++;\n\t\t\t\t\t\tif (runX == 5)\n\t\t\t\t\t\t\tresult += QrCode.PENALTY_N1;\n\t\t\t\t\t\telse if (runX > 5)\n\t\t\t\t\t\t\tresult++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tQrCode.finderPenaltyAddHistory(runX + padRun, runHistory);\n\t\t\t\t\t\tpadRun = 0;\n\t\t\t\t\t\tif (!runColor)\n\t\t\t\t\t\t\tresult += finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;\n\t\t\t\t\t\trunColor = modules[y][x];\n\t\t\t\t\t\trunX = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult += finderPenaltyTerminateAndCount(runColor, runX + padRun, runHistory) * QrCode.PENALTY_N3;\n\t\t\t}\n\t\t\t// Adjacent modules in column having same color, and finder-like patterns\n\t\t\tfor (var x = 0; x < size; x++) {\n\t\t\t\tvar runColor = false;\n\t\t\t\tvar runY = 0;\n\t\t\t\tvar runHistory = [0, 0, 0, 0, 0, 0, 0];\n\t\t\t\tvar padRun = size;\n\t\t\t\tfor (var y = 0; y < size; y++) {\n\t\t\t\t\tif (modules[y][x] == runColor) {\n\t\t\t\t\t\trunY++;\n\t\t\t\t\t\tif (runY == 5)\n\t\t\t\t\t\t\tresult += QrCode.PENALTY_N1;\n\t\t\t\t\t\telse if (runY > 5)\n\t\t\t\t\t\t\tresult++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tQrCode.finderPenaltyAddHistory(runY + padRun, runHistory);\n\t\t\t\t\t\tpadRun = 0;\n\t\t\t\t\t\tif (!runColor)\n\t\t\t\t\t\t\tresult += finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;\n\t\t\t\t\t\trunColor = modules[y][x];\n\t\t\t\t\t\trunY = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult += finderPenaltyTerminateAndCount(runColor, runY + padRun, runHistory) * QrCode.PENALTY_N3;\n\t\t\t}\n\n\t\t\t// 2*2 blocks of modules having same color\n\t\t\tfor (var y = 0; y < size - 1; y++) {\n\t\t\t\tfor (var x = 0; x < size - 1; x++) {\n\t\t\t\t\tvar color = modules[y][x];\n\t\t\t\t\tif (color == modules[y][x + 1] &&\n\t\t\t\t\t\tcolor == modules[y + 1][x] &&\n\t\t\t\t\t\tcolor == modules[y + 1][x + 1])\n\t\t\t\t\t\tresult += QrCode.PENALTY_N2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Balance of black and white modules\n\t\t\tvar black = 0;\n\t\t\tmodules.forEach(function (row) {\n\t\t\t\trow.forEach(function (color) {\n\t\t\t\t\tif (color)\n\t\t\t\t\t\tblack++;\n\t\t\t\t});\n\t\t\t});\n\t\t\tvar total = size * size; // Note that size is odd, so black/total != 1/2\n\t\t\t// Compute the smallest integer k >= 0 such that (45-5k)% <= black/total <= (55+5k)%\n\t\t\tvar k = Math.ceil(Math.abs(black * 20 - total * 10) / total) - 1;\n\t\t\tresult += k * QrCode.PENALTY_N4;\n\t\t\treturn result;\n\t\t}\n\n\n\t\t// Returns an ascending list of positions of alignment patterns for this version number.\n\t\t// Each position is in the range [0,177), and are used on both the x and y axes.\n\t\t// This could be implemented as lookup table of 40 variable-length lists of integers.\n\t\tfunction getAlignmentPatternPositions() {\n\t\t\tif (version == 1)\n\t\t\t\treturn [];\n\t\t\telse {\n\t\t\t\tvar numAlign = Math.floor(version / 7) + 2;\n\t\t\t\tvar step = (version == 32) ? 26 :\n\t\t\t\t\tMath.ceil((size - 13) / (numAlign * 2 - 2)) * 2;\n\t\t\t\tvar result = [6];\n\t\t\t\tfor (var pos = size - 7; result.length < numAlign; pos -= step)\n\t\t\t\t\tresult.splice(1, 0, pos);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\n\t\t// Can only be called immediately after a white run is added, and\n\t\t// returns either 0, 1, or 2. A helper function for getPenaltyScore().\n\t\tfunction finderPenaltyCountPatterns(runHistory) {\n\t\t\tvar n = runHistory[1];\n\t\t\tif (n > size * 3)\n\t\t\t\tthrow \"Assertion error\";\n\t\t\tvar core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;\n\t\t\treturn (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) +\n\t\t\t\t(core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);\n\t\t}\n\n\n\t\t// Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().\n\t\tfunction finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {\n\t\t\tif (currentRunColor) { // Terminate black run\n\t\t\t\tQrCode.finderPenaltyAddHistory(currentRunLength, runHistory);\n\t\t\t\tcurrentRunLength = 0;\n\t\t\t}\n\t\t\tcurrentRunLength += size; // Add white border to final run\n\t\t\tQrCode.finderPenaltyAddHistory(currentRunLength, runHistory);\n\t\t\treturn finderPenaltyCountPatterns(runHistory);\n\t\t}\n\n\n\t\t// Returns true iff the i'th bit of x is set to 1.\n\t\tfunction getBit(x, i) {\n\t\t\treturn ((x >>> i) & 1) != 0;\n\t\t}\n\t};\n\n\n\t/*---- Static factory functions (high level) for QrCode ----*/\n\n\t/* \n\t * Returns a QR Code representing the given Unicode text string at the given error correction level.\n\t * As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer\n\t * Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible\n\t * QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the\n\t * ecl argument if it can be done without increasing the version.\n\t */\n\tthis.QrCode.encodeText = function (text, ecl) {\n\t\tvar segs = qrcodegen.QrSegment.makeSegments(text);\n\t\treturn this.encodeSegments(segs, ecl);\n\t};\n\n\n\t/* \n\t * Returns a QR Code representing the given binary data at the given error correction level.\n\t * This function always encodes using the binary segment mode, not any text mode. The maximum number of\n\t * bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.\n\t * The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.\n\t */\n\tthis.QrCode.encodeBinary = function (data, ecl) {\n\t\tvar seg = qrcodegen.QrSegment.makeBytes(data);\n\t\treturn this.encodeSegments([seg], ecl);\n\t};\n\n\n\t/*---- Static factory functions (mid level) for QrCode ----*/\n\n\t/* \n\t * Returns a QR Code representing the given segments with the given encoding parameters.\n\t * The smallest possible QR Code version within the given range is automatically\n\t * chosen for the output. Iff boostEcl is true, then the ECC level of the result\n\t * may be higher than the ecl argument if it can be done without increasing the\n\t * version. The mask number is either between 0 to 7 (inclusive) to force that\n\t * mask, or -1 to automatically choose an appropriate mask (which may be slow).\n\t * This function allows the user to create a custom sequence of segments that switches\n\t * between modes (such as alphanumeric and byte) to encode text in less space.\n\t * This is a mid-level API; the high-level API is encodeText() and encodeBinary().\n\t */\n\tthis.QrCode.encodeSegments = function (segs, ecl, minVersion, maxVersion, mask, boostEcl) {\n\t\tif (minVersion == undefined) minVersion = MIN_VERSION;\n\t\tif (maxVersion == undefined) maxVersion = MAX_VERSION;\n\t\tif (mask == undefined) mask = -1;\n\t\tif (boostEcl == undefined) boostEcl = true;\n\t\tif (!(MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= MAX_VERSION) || mask < -1 || mask > 7)\n\t\t\tthrow \"Invalid value\";\n\n\t\t// Find the minimal version number to use\n\t\tvar version, dataUsedBits;\n\t\tfor (version = minVersion;; version++) {\n\t\t\tvar dataCapacityBits = QrCode.getNumDataCodewords(version, ecl) * 8; // Number of data bits available\n\t\t\tdataUsedBits = qrcodegen.QrSegment.getTotalBits(segs, version);\n\t\t\tif (dataUsedBits <= dataCapacityBits)\n\t\t\t\tbreak; // This version number is found to be suitable\n\t\t\tif (version >= maxVersion) // All versions in the range could not fit the given data\n\t\t\t\tthrow \"Data too long\";\n\t\t}\n\n\t\t// Increase the error correction level while the data still fits in the current version number\n\t\t[this.Ecc.MEDIUM, this.Ecc.QUARTILE, this.Ecc.HIGH].forEach(function (newEcl) { // From low to high\n\t\t\tif (boostEcl && dataUsedBits <= QrCode.getNumDataCodewords(version, newEcl) * 8)\n\t\t\t\tecl = newEcl;\n\t\t});\n\n\t\t// Concatenate all segments to create the data bit string\n\t\tvar bb = new BitBuffer();\n\t\tsegs.forEach(function (seg) {\n\t\t\tbb.appendBits(seg.mode.modeBits, 4);\n\t\t\tbb.appendBits(seg.numChars, seg.mode.numCharCountBits(version));\n\t\t\tseg.getData().forEach(function (bit) {\n\t\t\t\tbb.push(bit);\n\t\t\t});\n\t\t});\n\t\tif (bb.length != dataUsedBits)\n\t\t\tthrow \"Assertion error\";\n\n\t\t// Add terminator and pad up to a byte if applicable\n\t\tvar dataCapacityBits = QrCode.getNumDataCodewords(version, ecl) * 8;\n\t\tif (bb.length > dataCapacityBits)\n\t\t\tthrow \"Assertion error\";\n\t\tbb.appendBits(0, Math.min(4, dataCapacityBits - bb.length));\n\t\tbb.appendBits(0, (8 - bb.length % 8) % 8);\n\t\tif (bb.length % 8 != 0)\n\t\t\tthrow \"Assertion error\";\n\n\t\t// Pad with alternating bytes until data capacity is reached\n\t\tfor (var padByte = 0xEC; bb.length < dataCapacityBits; padByte ^= 0xEC ^ 0x11)\n\t\t\tbb.appendBits(padByte, 8);\n\n\t\t// Pack bits into bytes in big endian\n\t\tvar dataCodewords = [];\n\t\twhile (dataCodewords.length * 8 < bb.length)\n\t\t\tdataCodewords.push(0);\n\t\tbb.forEach(function (bit, i) {\n\t\t\tdataCodewords[i >>> 3] |= bit << (7 - (i & 7));\n\t\t});\n\n\t\t// Create the QR Code object\n\t\treturn new this(version, ecl, dataCodewords, mask);\n\t};\n\n\n\t/*---- Private static helper functions for QrCode ----*/\n\n\tvar QrCode = {}; // Private object to assign properties to. Not the same object as 'this.QrCode'.\n\n\n\t// Returns the number of data bits that can be stored in a QR Code of the given version number, after\n\t// all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.\n\t// The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.\n\tQrCode.getNumRawDataModules = function (ver) {\n\t\tif (ver < MIN_VERSION || ver > MAX_VERSION)\n\t\t\tthrow \"Version number out of range\";\n\t\tvar result = (16 * ver + 128) * ver + 64;\n\t\tif (ver >= 2) {\n\t\t\tvar numAlign = Math.floor(ver / 7) + 2;\n\t\t\tresult -= (25 * numAlign - 10) * numAlign - 55;\n\t\t\tif (ver >= 7)\n\t\t\t\tresult -= 36;\n\t\t}\n\t\treturn result;\n\t};\n\n\n\t// Returns the number of 8-bit data (i.e. not error correction) codewords contained in any\n\t// QR Code of the given version number and error correction level, with remainder bits discarded.\n\t// This stateless pure function could be implemented as a (40*4)-cell lookup table.\n\tQrCode.getNumDataCodewords = function (ver, ecl) {\n\t\treturn Math.floor(QrCode.getNumRawDataModules(ver) / 8) -\n\t\t\tQrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] *\n\t\t\tQrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n\t};\n\n\n\t// Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be\n\t// implemented as a lookup table over all possible parameter values, instead of as an algorithm.\n\tQrCode.reedSolomonComputeDivisor = function (degree) {\n\t\tif (degree < 1 || degree > 255)\n\t\t\tthrow \"Degree out of range\";\n\t\t// Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.\n\t\t// For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the uint8 array [255, 8, 93].\n\t\tvar result = [];\n\t\tfor (var i = 0; i < degree - 1; i++)\n\t\t\tresult.push(0);\n\t\tresult.push(1); // Start off with the monomial x^0\n\n\t\t// Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),\n\t\t// and drop the highest monomial term which is always 1x^degree.\n\t\t// Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).\n\t\tvar root = 1;\n\t\tfor (var i = 0; i < degree; i++) {\n\t\t\t// Multiply the current product by (x - r^i)\n\t\t\tfor (var j = 0; j < result.length; j++) {\n\t\t\t\tresult[j] = QrCode.reedSolomonMultiply(result[j], root);\n\t\t\t\tif (j + 1 < result.length)\n\t\t\t\t\tresult[j] ^= result[j + 1];\n\t\t\t}\n\t\t\troot = QrCode.reedSolomonMultiply(root, 0x02);\n\t\t}\n\t\treturn result;\n\t};\n\n\n\t// Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.\n\tQrCode.reedSolomonComputeRemainder = function (data, divisor) {\n\t\tvar result = divisor.map(function () {\n\t\t\treturn 0;\n\t\t});\n\t\tdata.forEach(function (b) { // Polynomial division\n\t\t\tvar factor = b ^ result.shift();\n\t\t\tresult.push(0);\n\t\t\tdivisor.forEach(function (coef, i) {\n\t\t\t\tresult[i] ^= QrCode.reedSolomonMultiply(coef, factor);\n\t\t\t});\n\t\t});\n\t\treturn result;\n\t};\n\n\n\t// Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result\n\t// are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.\n\tQrCode.reedSolomonMultiply = function (x, y) {\n\t\tif (x >>> 8 != 0 || y >>> 8 != 0)\n\t\t\tthrow \"Byte out of range\";\n\t\t// Russian peasant multiplication\n\t\tvar z = 0;\n\t\tfor (var i = 7; i >= 0; i--) {\n\t\t\tz = (z << 1) ^ ((z >>> 7) * 0x11D);\n\t\t\tz ^= ((y >>> i) & 1) * x;\n\t\t}\n\t\tif (z >>> 8 != 0)\n\t\t\tthrow \"Assertion error\";\n\t\treturn z;\n\t};\n\n\n\t// Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().\n\tQrCode.finderPenaltyAddHistory = function (currentRunLength, runHistory) {\n\t\trunHistory.pop();\n\t\trunHistory.unshift(currentRunLength);\n\t};\n\n\n\t// Tests whether the given run history has the pattern of ratio 1:1:3:1:1 in the middle, and\n\t// surrounded by at least 4 on either or both ends. A helper function for getPenaltyScore().\n\t// Must only be called immediately after a run of white modules has ended.\n\tQrCode.hasFinderLikePattern = function (runHistory) {\n\t\tvar n = runHistory[1];\n\t\treturn n > 0 && runHistory[2] == n && runHistory[4] == n && runHistory[5] == n &&\n\t\t\trunHistory[3] == n * 3 && Math.max(runHistory[0], runHistory[6]) >= n * 4;\n\t};\n\n\n\t/*---- Constants and tables for QrCode ----*/\n\n\tvar MIN_VERSION = 1; // The minimum version number supported in the QR Code Model 2 standard\n\tvar MAX_VERSION = 40; // The maximum version number supported in the QR Code Model 2 standard\n\tObject.defineProperty(this.QrCode, \"MIN_VERSION\", {\n\t\tvalue: MIN_VERSION\n\t});\n\tObject.defineProperty(this.QrCode, \"MAX_VERSION\", {\n\t\tvalue: MAX_VERSION\n\t});\n\n\t// For use in getPenaltyScore(), when evaluating which mask is best.\n\tQrCode.PENALTY_N1 = 3;\n\tQrCode.PENALTY_N2 = 3;\n\tQrCode.PENALTY_N3 = 40;\n\tQrCode.PENALTY_N4 = 10;\n\n\tQrCode.ECC_CODEWORDS_PER_BLOCK = [\n\t\t// Version: (note that index 0 is for padding, and is set to an illegal value)\n\t\t//  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n\t\t[null, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], // Low\n\t\t[null, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28], // Medium\n\t\t[null, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], // Quartile\n\t\t[null, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], // High\n\t];\n\n\tQrCode.NUM_ERROR_CORRECTION_BLOCKS = [\n\t\t// Version: (note that index 0 is for padding, and is set to an illegal value)\n\t\t//  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n\t\t[null, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25], // Low\n\t\t[null, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49], // Medium\n\t\t[null, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68], // Quartile\n\t\t[null, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81], // High\n\t];\n\n\n\t/*---- Public helper enumeration ----*/\n\n\t/* \n\t * The error correction level in a QR Code symbol. Immutable.\n\t */\n\tthis.QrCode.Ecc = {\n\t\tLOW: new Ecc(0, 1), // The QR Code can tolerate about  7% erroneous codewords\n\t\tMEDIUM: new Ecc(1, 0), // The QR Code can tolerate about 15% erroneous codewords\n\t\tQUARTILE: new Ecc(2, 3), // The QR Code can tolerate about 25% erroneous codewords\n\t\tHIGH: new Ecc(3, 2), // The QR Code can tolerate about 30% erroneous codewords\n\t};\n\n\n\t// Private constructor.\n\tfunction Ecc(ord, fb) {\n\t\t// (Public) In the range 0 to 3 (unsigned 2-bit integer)\n\t\tObject.defineProperty(this, \"ordinal\", {\n\t\t\tvalue: ord\n\t\t});\n\n\t\t// (Package-private) In the range 0 to 3 (unsigned 2-bit integer)\n\t\tObject.defineProperty(this, \"formatBits\", {\n\t\t\tvalue: fb\n\t\t});\n\t}\n\n\n\n\t/*---- Data segment class ----*/\n\n\t/* \n\t * A segment of character/binary/control data in a QR Code symbol.\n\t * Instances of this class are immutable.\n\t * The mid-level way to create a segment is to take the payload data\n\t * and call a static factory function such as QrSegment.makeNumeric().\n\t * The low-level way to create a segment is to custom-make the bit buffer\n\t * and call the QrSegment() constructor with appropriate values.\n\t * This segment class imposes no length restrictions, but QR Codes have restrictions.\n\t * Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.\n\t * Any segment longer than this is meaningless for the purpose of generating QR Codes.\n\t * This constructor creates a QR Code segment with the given attributes and data.\n\t * The character count (numChars) must agree with the mode and the bit buffer length,\n\t * but the constraint isn't checked. The given bit buffer is cloned and stored.\n\t */\n\tthis.QrSegment = function (mode, numChars, bitData) {\n\t\t/*---- Constructor (low level) ----*/\n\t\tif (numChars < 0 || !(mode instanceof Mode))\n\t\t\tthrow \"Invalid argument\";\n\n\t\t// The data bits of this segment. Accessed through getData().\n\t\tbitData = bitData.slice(); // Make defensive copy\n\n\t\t// The mode indicator of this segment.\n\t\tObject.defineProperty(this, \"mode\", {\n\t\t\tvalue: mode\n\t\t});\n\n\t\t// The length of this segment's unencoded data. Measured in characters for\n\t\t// numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.\n\t\t// Always zero or positive. Not the same as the data's bit length.\n\t\tObject.defineProperty(this, \"numChars\", {\n\t\t\tvalue: numChars\n\t\t});\n\n\t\t// Returns a new copy of the data bits of this segment.\n\t\tthis.getData = function () {\n\t\t\treturn bitData.slice(); // Make defensive copy\n\t\t};\n\t};\n\n\n\t/*---- Static factory functions (mid level) for QrSegment ----*/\n\n\t/* \n\t * Returns a segment representing the given binary data encoded in\n\t * byte mode. All input byte arrays are acceptable. Any text string\n\t * can be converted to UTF-8 bytes and encoded as a byte mode segment.\n\t */\n\tthis.QrSegment.makeBytes = function (data) {\n\t\tvar bb = new BitBuffer();\n\t\tdata.forEach(function (b) {\n\t\t\tbb.appendBits(b, 8);\n\t\t});\n\t\treturn new this(this.Mode.BYTE, data.length, bb);\n\t};\n\n\n\t/* \n\t * Returns a segment representing the given string of decimal digits encoded in numeric mode.\n\t */\n\tthis.QrSegment.makeNumeric = function (digits) {\n\t\tif (!this.NUMERIC_REGEX.test(digits))\n\t\t\tthrow \"String contains non-numeric characters\";\n\t\tvar bb = new BitBuffer();\n\t\tfor (var i = 0; i < digits.length;) { // Consume up to 3 digits per iteration\n\t\t\tvar n = Math.min(digits.length - i, 3);\n\t\t\tbb.appendBits(parseInt(digits.substring(i, i + n), 10), n * 3 + 1);\n\t\t\ti += n;\n\t\t}\n\t\treturn new this(this.Mode.NUMERIC, digits.length, bb);\n\t};\n\n\n\t/* \n\t * Returns a segment representing the given text string encoded in alphanumeric mode.\n\t * The characters allowed are: 0 to 9, A to Z (uppercase only), space,\n\t * dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n\t */\n\tthis.QrSegment.makeAlphanumeric = function (text) {\n\t\tif (!this.ALPHANUMERIC_REGEX.test(text))\n\t\t\tthrow \"String contains unencodable characters in alphanumeric mode\";\n\t\tvar bb = new BitBuffer();\n\t\tvar i;\n\t\tfor (i = 0; i + 2 <= text.length; i += 2) { // Process groups of 2\n\t\t\tvar temp = QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;\n\t\t\ttemp += QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));\n\t\t\tbb.appendBits(temp, 11);\n\t\t}\n\t\tif (i < text.length) // 1 character remaining\n\t\t\tbb.appendBits(QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6);\n\t\treturn new this(this.Mode.ALPHANUMERIC, text.length, bb);\n\t};\n\n\n\t/* \n\t * Returns a new mutable list of zero or more segments to represent the given Unicode text string.\n\t * The result may use various segment modes and switch modes to optimize the length of the bit stream.\n\t */\n\tthis.QrSegment.makeSegments = function (text) {\n\t\t// Select the most efficient segment encoding automatically\n\t\tif (text == \"\")\n\t\t\treturn [];\n\t\telse if (this.NUMERIC_REGEX.test(text))\n\t\t\treturn [this.makeNumeric(text)];\n\t\telse if (this.ALPHANUMERIC_REGEX.test(text))\n\t\t\treturn [this.makeAlphanumeric(text)];\n\t\telse\n\t\t\treturn [this.makeBytes(toUtf8ByteArray(text))];\n\t};\n\n\n\t/* \n\t * Returns a segment representing an Extended Channel Interpretation\n\t * (ECI) designator with the given assignment value.\n\t */\n\tthis.QrSegment.makeEci = function (assignVal) {\n\t\tvar bb = new BitBuffer();\n\t\tif (assignVal < 0)\n\t\t\tthrow \"ECI assignment value out of range\";\n\t\telse if (assignVal < (1 << 7))\n\t\t\tbb.appendBits(assignVal, 8);\n\t\telse if (assignVal < (1 << 14)) {\n\t\t\tbb.appendBits(2, 2);\n\t\t\tbb.appendBits(assignVal, 14);\n\t\t} else if (assignVal < 1000000) {\n\t\t\tbb.appendBits(6, 3);\n\t\t\tbb.appendBits(assignVal, 21);\n\t\t} else\n\t\t\tthrow \"ECI assignment value out of range\";\n\t\treturn new this(this.Mode.ECI, 0, bb);\n\t};\n\n\n\t// (Package-private) Calculates and returns the number of bits needed to encode the given segments at the\n\t// given version. The result is infinity if a segment has too many characters to fit its length field.\n\tthis.QrSegment.getTotalBits = function (segs, version) {\n\t\tvar result = 0;\n\t\tfor (var i = 0; i < segs.length; i++) {\n\t\t\tvar seg = segs[i];\n\t\t\tvar ccbits = seg.mode.numCharCountBits(version);\n\t\t\tif (seg.numChars >= (1 << ccbits))\n\t\t\t\treturn Infinity; // The segment's length doesn't fit the field's bit width\n\t\t\tresult += 4 + ccbits + seg.getData().length;\n\t\t}\n\t\treturn result;\n\t};\n\n\n\t/*---- Constants for QrSegment ----*/\n\n\tvar QrSegment = {}; // Private object to assign properties to. Not the same object as 'this.QrSegment'.\n\n\t// (Public) Describes precisely all strings that are encodable in numeric mode.\n\t// To test whether a string s is encodable: var ok = NUMERIC_REGEX.test(s);\n\t// A string is encodable iff each character is in the range 0 to 9.\n\tthis.QrSegment.NUMERIC_REGEX = /^[0-9]*$/;\n\n\t// (Public) Describes precisely all strings that are encodable in alphanumeric mode.\n\t// To test whether a string s is encodable: var ok = ALPHANUMERIC_REGEX.test(s);\n\t// A string is encodable iff each character is in the following set: 0 to 9, A to Z\n\t// (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n\tthis.QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\\/:-]*$/;\n\n\t// (Private) The set of all legal characters in alphanumeric mode,\n\t// where each character value maps to the index in the string.\n\tQrSegment.ALPHANUMERIC_CHARSET = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\";\n\n\n\t/*---- Public helper enumeration ----*/\n\n\t/* \n\t * Describes how a segment's data bits are interpreted. Immutable.\n\t */\n\tthis.QrSegment.Mode = { // Constants\n\t\tNUMERIC: new Mode(0x1, [10, 12, 14]),\n\t\tALPHANUMERIC: new Mode(0x2, [9, 11, 13]),\n\t\tBYTE: new Mode(0x4, [8, 16, 16]),\n\t\tKANJI: new Mode(0x8, [8, 10, 12]),\n\t\tECI: new Mode(0x7, [0, 0, 0]),\n\t};\n\n\n\t// Private constructor.\n\tfunction Mode(mode, ccbits) {\n\t\t// (Package-private) The mode indicator bits, which is a uint4 value (range 0 to 15).\n\t\tObject.defineProperty(this, \"modeBits\", {\n\t\t\tvalue: mode\n\t\t});\n\n\t\t// (Package-private) Returns the bit width of the character count field for a segment in\n\t\t// this mode in a QR Code at the given version number. The result is in the range [0, 16].\n\t\tthis.numCharCountBits = function (ver) {\n\t\t\treturn ccbits[Math.floor((ver + 7) / 17)];\n\t\t};\n\t}\n\n\n\n\t/*---- Private helper functions and classes ----*/\n\n\t// Returns a new array of bytes representing the given string encoded in UTF-8.\n\tfunction toUtf8ByteArray(str) {\n\t\tstr = encodeURI(str);\n\t\tvar result = [];\n\t\tfor (var i = 0; i < str.length; i++) {\n\t\t\tif (str.charAt(i) != \"%\")\n\t\t\t\tresult.push(str.charCodeAt(i));\n\t\t\telse {\n\t\t\t\tresult.push(parseInt(str.substring(i + 1, i + 3), 16));\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\n\t/* \n\t * A private helper class that represents an appendable sequence of bits (0s and 1s).\n\t * Mainly used by QrSegment. This constructor creates an empty bit buffer (length 0).\n\t */\n\tfunction BitBuffer() {\n\t\tArray.call(this);\n\n\t\t// Appends the given number of low-order bits of the given value\n\t\t// to this buffer. Requires 0 <= len <= 31 and 0 <= val < 2^len.\n\t\tthis.appendBits = function (val, len) {\n\t\t\tif (len < 0 || len > 31 || val >>> len != 0)\n\t\t\t\tthrow \"Value out of range\";\n\t\t\tfor (var i = len - 1; i >= 0; i--) // Append bit by bit\n\t\t\t\tthis.push((val >>> i) & 1);\n\t\t};\n\t}\n\n\tBitBuffer.prototype = Object.create(Array.prototype);\n\tBitBuffer.prototype.constructor = BitBuffer;\n\n};\n\n"],
  "mappings": "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",
  "names": ["version", "errCorLvl", "dataCodewords", "mask", "MIN_VERSION", "MAX_VERSION", "Ecc", "size", "row", "i", "modules", "isFunction", "drawFunctionPatterns", "allCodewords", "addEccAndInterleave", "drawCodewords", "minPenalty", "applyMask", "drawFormatBits", "penalty", "getPenaltyScore", "x", "y", "scale", "border", "canvas", "width", "ctx", "parts", "setFunctionModule", "drawFinderPattern", "alignPatPos", "getAlignmentPatternPositions", "numAlign", "j", "drawAlignmentPattern", "drawVersion", "data", "rem", "bits", "getBit", "bit", "a", "b", "dy", "dx", "dist", "xx", "yy", "isBlack", "QrCode", "numBlocks", "blockEccLen", "rawCodewords", "numShortBlocks", "shortBlockLen", "blocks", "rsDiv", "k", "dat", "ecc", "result", "right", "vert", "upward", "invert", "runColor", "runX", "runHistory", "padRun", "finderPenaltyCountPatterns", "finderPenaltyTerminateAndCount", "runY", "color", "black", "total", "step", "pos", "n", "core", "currentRunColor", "currentRunLength", "text", "ecl", "segs", "seg", "minVersion", "maxVersion", "boostEcl", "dataUsedBits", "dataCapacityBits", "newEcl", "bb", "BitBuffer", "padByte", "ver", "degree", "root", "divisor", "factor", "coef", "z", "ord", "fb", "mode", "numChars", "bitData", "Mode", "digits", "temp", "QrSegment", "toUtf8ByteArray", "assignVal", "ccbits", "str", "val", "len"]
}
